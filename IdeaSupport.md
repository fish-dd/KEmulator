# Поддержка IntelliJ IDEA

Отличие J2ME "MIDP/CLDC" от J2SE по сути, написано в названии: это другая стдлиба. А ещё более "слабая" версия языка.
Теоретически, любую имплементацию JRE можно запускать любым отладчиком, пока они реализуют протокол отладки по
спецификации.
Ещё больше задача упрощается тем что кемулятор работает поверх обычного хотспота из 1.8.
Таким образом, задача запуска/сборки проекта под кемулятором из IDE ничего не знающей про J2ME сводится к простановке
корректного "корневого" (и не-"корневого") класспатча а так же нескольких опций (по типу требуемой версии байткода).

Поскольку ручная настройка занимает 20 шагов не очень очевидного ползания по менюшкам и вбивания туда ещё более не очень
очевидных
вещей (и периодически слетает при перезапуске IDE если она заподозрила что ваша JDK 1.8 не совсем J2SEDK и не совсем
1.8), было принято решение сделать мастер настройки который спросит у юзера где у него что лежит и сам впишет нужное в
конфиг идеи.

Ниже содержится вольное объяснение как устроена штука вперемешку с документацией на CLI и списком проблем с которыми вы
точно столкнётесь (выделено **жирным**). Ещё тут можно найти список того **что надо или не надо делать чтоб ваш проект
не
развалился.** Документ будет дополняться по мере развития штуки.

## CLI

Поскольку кемулятор может работать только с PWD в своей папке, путь к PWD вызова всегда должен быть передан вторым
аргументом. Bash-стартер это выполняет внутри себя, схема вызова выглядит примерно как
`-jar KEm.jar $1 $PWD $2 $3 $4...`.
Примеры:

```
/usr/share/kemulator$ java -Dfile.encoding=UTF-8 -jar KEmulator.jar -command ~/code arg1 arg2
~/code$ kemulator -command arg1 arg2
```

### -new-project

Создаёт новый проект в текущем каталоге. Со `stdin` ожидает через `\n`:

- Имя папки/проекта.
- Имя java-class'а мидлета.
- Имя мидлета для юзера.

Вернёт 0 в случае успеха. Рекомендуется запускать в интерактивном эмуляторе терминала и вводить данные ручками.

### -restore

Восстанавливает проект, пересоздавая конфигурации сборки и запуска. Не требует ввода. Вернёт 0 в случае успеха.

### -convert

Ищет в текущем каталоге `Application Descriptor`, читает его как манифест проекта на Eclipse MTJ и выполняет
конвертацию. Автоматически вызывает восстановление. Вернёт 0 в случае успеха. В отличие от кнопочки в GUI, не запускает
IDE, используйте `kemulator -edit`.

### -edit

Запускает IDEA для текущего каталога. Ничего не проверяет, можно выполнять в любой папке. Полностью эквивалентно вызову
`idea` без аргументов, если она у вас находится в $PATH.

## Общая картина

При первичной настройке кем запоминает внутри себя путь к идее и прогарду. В конфигурацию JDK идеи добавляются две
фальшивые JDK, для разработки и запуска. Затем сбрасывается кеш, поскольку пересчёт его частей ответственных за
индексацию библиотек выполняется по нажатию кнопки "ок" в меню списка JDK, а не по регистрации изменения конфига. В
худшем случае за идеей замечены попытки отката конфигурации на предыдыдущую до правок.

При создании проекта создаётся основная структура папок и конфигураций, файл модуля, типовой манифест и "hello world"
мидлет. Полученный проект сразу готов к запуску и/или упаковке. **Если вы пользуетесь штукой в первый раз, это то что вы
должны проверить немедленно** во избежание борьбы с ветряными мельницами в будущем.

При конвертации вычитывается существующий Application Descriptor и `.classpath`. На их основе кемулятор пытается
воссоздать вашу конфигурацию для интеллиж. Любые папки сорцов подвязываются как папки сорцов, папки `res` как папки
ресурсов. Найденные жарники добавляются как анонимные библиотеки в класспатч. Из списка мидлетов с манифеста создаются
конфигурации запуска. Если в проекте не была **задействована чёрная магия по типу переопределения переменных путей**,
кемулятор может съесть и выдать конфигурации довольно заковыристых образцов, например VK4ME, JTube, mobap-game. В том
числе есть обработка не-копируемых библиотек и нескольких мидлетов в одном пакете. Эклипс можно продолжать использовать
с некоторыми ограничениями.

В обоих случаях будут загитигнорены конфиги прогарда (с локальными путями) и конфиги запусков. После переноса проекта на
другую машину (и даже в другую папку) их надо пересоздавать. А ещё это надо делать если вы переименовали мидлет или
добавили ещё один. Или если добавили внешнюю библиотеку. **"Интеграция" не занимается автоматическим отслеживанием
изменений в файлах проекта. Это инструмент для генерирования конфигураций. Любое изменение вещей, "скопированных" в
какой-то конфиг (например `proguard-local.cfg`) сломает эту самую захардкоженную конфигурацию. В любой непонятной
ситуации необходимо выполнить `kemulator -restore`, либо нажать соответствующую кнопку в интерфейсе утилит, либо
запустить соответстующую конфигурацию в идее.**

Неполный список когда `-restore` выполнить НУЖНО средствами самого кемуля:

- git clone репозитория
- перенос проекта в другую папку
- перенос проекта на другую машину
- перемещение кемулятора
- перемещение прогарда

Неполный список когда восстановление выполнить можно/нужно в т.ч. конфигурацией идеи:

- новый/удалённый/изменённый класс мидлета
- правка списка мидлетов в манифесте
- любая правка в библиотеках, класспатче или модуле.

Во избежание лишней головной боли восстановление автоматически запускается перед попыткой "упаковать" жарник.
Конфигурации запуска через кемуль этого НЕ делают, поэтому при попытке переименовать мидлет и тут же нажать ctrl+F5
кемуль выдаст ошибку несуществующего класса.

## Devtime-JDK

При разработке IDE должна забыть про стдлибу J2SEDK 1.8 и вместо этого предлагать программисту подсказки по мешной
стдлибе. Это достигается удалением стандартного корневого класспатча и добавлением в него всего содержимого папки uei.
Библиотеки тут не имеют реализаций, только пустые объявления, но для работы
автодополнений/поисков/рефакторинга/компиляции этого достаточно. Запуститься проект в таких условиях, разумеется, не
сможет, но оно и не нужно.

## Runtime-JDK

В корневом класспатче оставляется J2SEDK 1.8, так как кемулятор реализован поверх неё.
Так же в корневой добавляются жарники самого кемулятора, так как он должен загрузиться до загрузки классов проекта.
Это необходимо для корректного срабатывания переопределений методов (например, CLDCшный util.Timer работает отлично от
J2SEшного, кемулятор поставляет собственную имплементацию и заменяет ей системную).
В основной класспатч добавляется сам проект.

В качестве точки входа указывается main() в жарнике кемулятора - на момент пуска проекта он уже загружен и хотспот не
замечает подвоха.
В аргументы кемулятору передаётся путь к жаду и класспатчу из которого грузится проект - это нужно для корректной
установки хуков чтения ресурсов и пропертисов.

Получившаяся вундервафля не теряет ресурсы и поддерживает горячую перезагрузку (с отладчиком).

## Жавадоки

По хорошему, должны лежать в ./uei/javadocs, там, где их ожидает эклипс.
Поскольку они там, разумеется, не лежат, юзеру предлагается самостоятельно скачать говносборку Никиты, куда-то её
распаковать и отдать конфигуратору путь. Из этих путей будут надёрганы подходящие подпути и проставлены в Devtime-jdk. В
случае нежелания юзера этим заниматься есть кнопка включающая веб-доки из той же самой репы.

## Преверификация?

Разумеется, IDEA не знает что это. К счастью, хотспот тоже - поэтому сборка и отладка проекта будет работать и так.
Для упаковки под телефон понадобится прогард, который умеет её делать. Реализовано в виде "конфигурации запуска", где в
среду runtime-jdk подкидывается жарник прогарда и ему указывается что делать. Конфигуратор предлагает сам докачать в
папку кемуля либо куда-то в /opt/. **Жарник, получающийся после компиляции проекта средствами идеи (build artifact), не
готов к запуску на телефоне.** Для упаковки необходимо пользоваться созданным конфигом "запуска".

Конфиг прогарда с суффиксом `-local` генерируется "восстановлением" и содержит базовые опции и пути к библиотекам. Его
не следует править. Дополнительную конфигурацию (в т.ч. полное отключение обфускации) следует делать в конфиге без
суффикса, его же можно переносить между машинами.

## Сборка проектов с JAR-библиотеками

При запуске кемулятору скармливается общий класспатч, поэтому JAR библиотеки оказываются видны проекту и прекрасно им
могут вызываться. С упаковкой всё сложнее. Из-за того что я не нашёл в идее кнопки для объединения уже собранных
жарников, **копирование классов библиотек внутрь жара проекта осуществляется на этапе обработки прогардом.** Ошибки
дублирующихся манифестов не являются проблемой.

## Сосуществование проектов эклипса и идеи в одной папке

В эклипсе "файлом проекта" является де-факто манифест будущего приложения, который хранится в корне под именем
Application Descriptor. Поэтому при создании проекта с нуля манифест создаётся где нужно, а вот при конвертации
для "источника" манифеста используется дескриптор эклипса. В конфигурации артефакта прописывается копирование с
переименованием. Не рекомендуется держать в проекте одновременно дескриптор эклипса и MANIFEST.MF, особенно если их
содержимое разное. Инструментарий восстановления и сборки будет смотреть в первую очередь в дескриптор эклипса.

## Класспатчи при конвертации

В отличие от манифеста, **попытка конвертации создаст две полностью независимые конфигурации класспатча**. Если вы
добавляете новую библиотеку или папку с исходниками, это необходимо руками повторить для второй IDE. И вызвать
`-restore`, конечно. Как вариант, можно сделать всё в эклипсе, удалить руками IML и `.idea`, после чего заново
конвертировать проект.

## IDEA -> MTJ? Netbeans/ANT -> IDEA?

Конвертация ИЗ интеллиж во что-то другое не будет сделана никогда, так как в моих глазах пересадка с эклипса/нб на
жетбрайнс выглядит как переход с велосипеда на самолёт. Ант можно настроить руками и/или плагином идеи. Если
нужен двойной проект эклипс/идея, создайте и ПОЛНОСТЬЮ (см. выше почему) настройте проект в эклипсе, создайте мидлеты и
выполните конвертацию.

Конвертер из нетбинсов запланирован, но будет позже 2.20. Как вариант, можно ручками скопипастить класспатч в формате
эклипса (или дёрнуть из чужого проекта с гитхаба подходящий) и переименовать ваш манифест в дескриптор. Штирлиц,
разумеется, будет близок к провалу, но конвертер такое вполне слопает.

## Отладка кемуля из-под проекта?

Необходимо открыть меню брейкпоинтов, нажать плюсик, выбрать java метод, вбить ПОЛНОЕ имя класса кемулятора и метод,
например `emulator.Emulator` и `main`. Точка сработает.

## Глобальный пакет?

IDEA не поддерживает импорт классов из глобального пакета. Если весь ваш код за исключением библиотек расположен в нём,
проект будет работать. Задействовать `Class1` в `pkg.Class2` вы не сможете.

## Препроцессинг?

Под лозунгом "write once, run nowhere" в спецификации языка предусмотрено чуть менее чем ничего. Обычно этим занимаются
те или иные локальные костыли в MTJ или ANT'е, плохо совместимые друг с другом. Если вы от них зависите но хотите
использовать идею, без кастомных скриптов сборки, к сожалению, не обойдётся.
